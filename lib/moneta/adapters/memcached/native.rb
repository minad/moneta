require 'memcached'

module Moneta
  module Adapters
    # Memcached backend (using gem memcached)
    # @api public
    class MemcachedNative
      include Defaults
      include IncrementSupport
      include ExpiresSupport

      # @param [Hash] options
      # @option options [String] :server ('127.0.0.1:11211') Memcached server
      # @option options [String] :namespace Key namespace
      # @option options [Integer] :expires (604800) Default expiration time
      # @option options Other options passed to `Memcached#new`
      def initialize(options = {})
        server = options.delete(:server) || '127.0.0.1:11211'
        self.default_expires = options.delete(:expires) || 604800
        options.merge!(:prefix_key => options.delete(:namespace)) if options[:namespace]
        # We don't want a limitation on the key charset. Therefore we use the binary protocol.
        # It is also faster.
        options[:binary_protocol] = true unless options.include?(:binary_protocol)
        @cache = ::Memcached.new(server, options)
      end

      # (see Proxy#load)
      def load(key, options = {})
        value = @cache.get(key, false)
        if value && options.include?(:expires)
          store(key, value, options)
        else
          value
        end
      rescue ::Memcached::NotFound
      end

      # (see Proxy#store)
      def store(key, value, options = {})
        # TTL must be Fixnum
        @cache.set(key, value, ttl(options[:expires]) || 0, false)
        value
      end

      # (see Proxy#delete)
      def delete(key, options = {})
        value = @cache.get(key, false)
        @cache.delete(key)
        value
      rescue ::Memcached::NotFound
      end

      # (see Proxy#increment)
      def increment(key, amount = 1, options = {})
        result = if amount >= 0
          @cache.increment(key, amount)
        else
          @cache.decrement(key, -amount)
        end
        # HACK: Throw error if applied to invalid value
        convert_for_increment((@cache.get(key, false) rescue nil)) if result == 0
        result
      rescue ::Memcached::NotFound => ex
        store(key, amount.to_s, options)
        amount
      end

      # (see Proxy#clear)
      def clear(options = {})
        @cache.flush
        self
      end
    end
  end
end
